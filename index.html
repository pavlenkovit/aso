<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Павленко Виталий</title>

  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

  <link href="css/style.css" rel="stylesheet">

</head>

<body>

<div class="progress">
  <div class="progress-bar" role="progressbar" aria-valuenow="25" aria-valuemin="0" aria-valuemax="100"></div>
</div>

<nav class="navbar navbar-expand-lg fixed-top navbar-dark" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="index.html">Павленко Виталий</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Меню
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="#1">Теория</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#2">Данные</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#3">Пример</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#4">Цифры</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<header class="masthead" style="background-image: url('img/post-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-9 col-md-10 mx-auto">
        <div class="post-heading">
          <h1>Тематика для диплома</h1>
          <h2 class="subheading">Explainable AI ("объяснимый" ИИ)</h2>
          <span class="meta">Павленко Виталий, 3збАСУс1</span>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container">
    <div class="row">
      <div class="col-lg-9 col-md-10 mx-auto">
        <p>Мы создадим нейронную сеть, с помощью которой будем распознавать ручное написание цифры от 0 до 9. Рабочий пример займет несколько строк. Код будет понятен даже тем программистам, которые не имели дело с нейронными сетями ранее. Как это все работает, можно будет посмотреть прямо в браузере.</p>

        <h2 class="section-heading" id="1">Совсем немного теории</h2>
        <p>Нейронные сети возникли из исследований в области искусственного интеллекта, а именно, из попыток воспроизвести способность биологических нервных систем обучаться и исправлять ошибки, моделируя низкоуровневую структуру мозга. В простейшем случае она состоит из нескольких соединенных между собой нейронов.</p>
        <h3 class="subheading">Математический нейрон</h3>
        <p>Несложный автомат, преобразующий входные сигналы в результирующий выходной сигнал.</p>
        <figure>
          <p>
            <img src="https://hsto.org/getpro/habr/post_images/7da/882/845/7da8828451ad8733c647137e7b25d18a.gif" alt="">
          </p>
        </figure>

        <p>Сигналы x1, x2, x3 … xn, поступая на вход, преобразуются линейным образом, т.е. к телу нейрона поступают силы: w1x1, w2x2, w3x3 … wnxn, где wi – веса соответствующих сигналов. Нейрон суммирует эти сигналы, затем применяет к сумме некоторую функцию f(x) и выдаёт полученный выходной сигнал y.
        </p>
        <p>В качестве функции f(x) чаще всего используется сигмоидная или пороговая функции.</p>

        <figure>
          <p>
            <img src="https://hsto.org/getpro/habr/post_images/7f0/a3d/8bf/7f0a3d8bf652fcb6d5a991266a34f9f3.gif" alt="">
          </p>
        </figure>
        <p>Пороговая функция может принимать только два дискретных значения 0 или 1. Смена значения функции происходит при переходе через заданный порог T.+</p>
        <p>Сигмоидная – непрерывная функция, может принимать бесконечно много значений в диапазоне от 0 до 1.</p>
        <p>UPD: В комментариях также упоминаются функции ReLU и MaxOut как более современные.</p>
        <p>Архитектура нейронной сети может быть разной, мы рассмотрим одну из простых реализаций нейронной сети — Perceptron</p>
        <h3 class="subheading">Архитектура Perceptron</h3>

        <figure>
          <p>
            <img src="https://hsto.org/getpro/habr/post_images/e64/7f8/64a/e647f864a901dceace6ed54f7b961d98.png" alt="">
          </p>
        </figure>

        <p>Есть слой входных нейронов (где информация поступает из вне), слой выходных нейронов (откуда можно взять результат) и ряд, так-называемых, скрытых слоев между ними. Нейроны могут быть расположены в несколько слоёв. Каждая связь между нейронами имеет свой вес Wij</p>

        <h2 class="section-heading" id="2">Входные и выходные сигналы</h2>
        <p>Перед тем, как подавать сигналы на нейроны входящего слоя сети нам их нужно нормализовать. Нормализация входных данных — это процесс, при котором все входные данные проходят процесс «выравнивания», т.е. приведения к интервалу [0,1] или [-1,1]. Если не провести нормализацию, то входные данные будут оказывать дополнительное влияние на нейрон, что приведет к неверным решениям. Другими словами, как можно сравнивать величины разных порядков?</p>
        <p>На нейронах выходного слоя у нас тоже не будет чистой «1» или «0», это нормально. Есть некий порог, при котором мы будем считать, что получили «1» или «0». Про интерпретацию результатов поговорим позже.</p>
        <h2 class="section-heading" id="3">Пример</h2>
        <p>Для удобства я рекомендую себе поставить nodejs и npm.</p>
        <p>Мы будем описывать сеть с помощью библиотеки Brain.js. В конце статьи я также дам ссылки на другие библиотеки, которые можно будет сконфигурировать похожим образом. Brain.js мне понравился своей скоростью и возможностью сохранять натренированную модель.</p>
        <p>Давайте попробуем пример из документации — эмулятор функции XOR:</p>
        <pre>
          <code>
            var brain = require('brain.js');
            var net = new brain.NeuralNetwork();

            net.train([{input: [0, 0], output: [0]},
            {input: [0, 1], output: [1]},
            {input: [1, 0], output: [1]},
            {input: [1, 1], output: [0]}]);

            var output = net.run([1, 0]);  // [0.987]
            console.log(output);
          </code>
        </pre>
        <p>запишем все в файл simple1.js, чтоб пример заработал, поставим модуль brain и запустим</p>
        <pre>
          <code>
            npm install brain.js
            node simple1.js  # [ 0.9331839217737243 ]
          </code>
        </pre>
        <p>У нас 2 входящих нейрона и один нейрон на выходе, библиотека brain.js сама сконфигурирует скрытый слой и установит там столько нейронов, сколько сочтет нужным (в этом примере 3 нейрона).</p>
        <p>То, что мы передали в метод .train называется обучающей выборкой, каждый элемент которой состоит из массива объектов со свойством input и output (массив входящих и выходящих параметров). Мы не проводили нормализацию входящих данных, так как сами данные уже приведены в нужную форму.</p>
        <p>Обратите внимание: мы на выходе получаем не [0.987] а [0.9331...]. У вас может быть немного другое значение. Это нормально, так как алгоритм обучения использует случайные числа при подборе весовых коэффициентов.</p>
        <p>Метод .run применяется для получения ответа нейронной сети на заданный в аргументе массив входящих сигналов.</p>
        <p>Другие простые примеры можно посмотреть в документации brain</p>

        <h2 class="section-heading" id="4">Распознаем цифры</h2>
        <p>В начале нам нужно получить изображения с рукописными цифрами, приведенными к одному размеру. В нашем примере мы будем использовать модуль MNIST digits, набор тысяч 28x28px бинарных изображений рукописных цифр от 0 до 9:</p>

        <figure>
          <p>
            <img src="https://hsto.org/getpro/habr/post_images/366/21a/d71/36621ad7140e47a880bf3e6a1b7d81fb.png" alt="">
          </p>
        </figure>
        <p>Оригинальная база данных MNIST содержит 60 000 примеров для обучения и 10 000 примеров для тестирования, ее можно можно загрузить с сайта LeCun. Автор MNIST digits сделал доступной часть этих примеров для языка JavaScript, в библиотеке уже проведена нормализация входящих сигналов. С помощью этого модуля мы можем получать обучающую и тестовую выборку автоматически.</p>
        <p>Мне пришлось клонировать библиотеку MNIST digits, так как там есть небольшая путаница с данными. Я повторно загрузил 10 000 примеров из оригинальной базы данных, так что использовать надо MNIST digits из моего репозитория.</p>

        <h3 class="subheading">Конфигурация сети</h3>
        <p>Во входном слое нам необходимо 28x28=784 нейрона, на выходе 10 нейронов. Скрытый слой brain.js сконфигурирует сам. Забегая наперед, уточню: там будет 392 нейрона. Обучающая выборка будет сформирована модулем mnist</p>

        <h3 class="subheading">Тренируем модель</h3>
        <p>Установим mnist</p>
        <pre>
          <code>
          npm install https://github.com/ApelSYN/mnist
        </code>
        </pre>
        <p>Все готово, обучаем сеть</p>
        <pre>
          <code>
            const brain = require('brain.js');
            var net = new brain.NeuralNetwork();
            const fs = require('fs');
            const mnist = require('mnist');
            const set = mnist.set(1000, 0);
            const trainingSet = set.training;
            net.train(trainingSet,
            {
            errorThresh: 0.005,  // error threshold to reach
            iterations: 20000,   // maximum training iterations
            log: true,           // console.log() progress periodically
            logPeriod: 1,       // number of iterations between logging
            learningRate: 0.3    // learning rate
            }
            );

            let wstream = fs.createWriteStream('./data/mnistTrain.json');
            wstream.write(JSON.stringify(net.toJSON(),null,2));
            wstream.end();

            console.log('MNIST dataset with Brain.js train done.')
          </code>
        </pre>
        <p>Создаем сеть, получаем 1000 элементов обучающей выборки, вызываем метод .train, который производит обучение сети — сохраняем все в файл './data/mnistTrain.json' (не забудьте создать папку "./data").</p>
        <p>Если все сделали правильно, получите приблизительно такой результат:</p>
        <pre>
          <code>
            [root@HomeWebServer nn]# node train.js
            iterations: 0 training error: 0.060402555338691676
            iterations: 1 training error: 0.02802436102035996
            iterations: 2 training error: 0.020358600820106914
            iterations: 3 training error: 0.0159533285799183
            iterations: 4 training error: 0.012557029942873513
            iterations: 5 training error: 0.010245175822114688
            iterations: 6 training error: 0.008218147206099617
            iterations: 7 training error: 0.006798613211310184
            iterations: 8 training error: 0.005629051609641436
            iterations: 9 training error: 0.004910207736789503
            MNIST dataset with Brain.js train done.
          </code>
        </pre>
        <h3 class="subheading">Все можно распознавать</h3>

        <p>Осталось написать совсем немного кода — и система распознавания готова!</p>
        <pre>
          <code>
            const brain = require('brain.js'),
                  mnist = require('mnist');
            var net = new brain.NeuralNetwork();
            const set = mnist.set(0, 1);
            const testSet = set.test;
            net.fromJSON(require('./data/mnistTrain'));
            var output = net.run(testSet[0].input);
            console.log(testSet[0].output);
            console.log(output);
          </code>
        </pre>
        <p>Получаем 1 случайный тестовый пример из выборки 10 000 записей, загружаем натренированную ранее модель, передаем на вход сети тестовую запись и смотрим правильно ли она распозналась.</p>
        <p>Вот пример выполнения</p>
        <pre>
          <code>
            [ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 ]
            [ 0.0002863506627761867,
              0.00002389940760904011,
              0.00039954062883041345,
              0.9910109896013567,
              7.562879202664903e-7,
              0.0038756598319246837,
              0.000016752919557362786,
              0.0007205981595354964,
              0.13699517762991756,
              0.0011053963693377692 ]
          </code>
        </pre>
        <p>В примере в сеть на входящие нейроны поступила оцифрованная тройка (первый масив это идеальный ответ), на выходе сети мы получили массив елементов, один из которых близок к единице (0.9910109896013567) это тоже третий бит. Обратите внимание на четвертый бит там 7.56… в -7 степени, это такая форма записи чисел с плавающей точкой в JavaScript.</p>
        <p>Ну что же, распознавание прошло правильно. Поздравляю, наша сеть заработала!</p>

      </div>
    </div>
  </div>
</article>

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <p class="copyright text-muted">Павленко Виталий, 2020</p>
      </div>
    </div>
  </div>
</footer>

<script src="vendor/jquery/jquery.min.js"></script>
<script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/parallax/3.1.0/parallax.min.js"></script>

<script src="js/script.js"></script>

</body>

</html>
